

# This file was *autogenerated* from the file elliptic.sage
from sage.all_cmdline import *   # import sage library

_sage_const_50043062554237280172405801360375653460619548838234052036762494431728976610313 = Integer(50043062554237280172405801360375653460619548838234052036762494431728976610313); _sage_const_43327883319811199442996705732365163443043431995328598938729525921048235234958 = Integer(43327883319811199442996705732365163443043431995328598938729525921048235234958); _sage_const_45494814375791703888029144132071347443317277861841182091738819980027414195528 = Integer(45494814375791703888029144132071347443317277861841182091738819980027414195528); _sage_const_34736706601617260336801089627448256371787243214661931571076381713565253696521 = Integer(34736706601617260336801089627448256371787243214661931571076381713565253696521); _sage_const_5887497935320424287803691270199037907654978138532428031269063384390017951571 = Integer(5887497935320424287803691270199037907654978138532428031269063384390017951571); _sage_const_2550513000803 = Integer(2550513000803); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_32 = Integer(32)
from Crypto.Protocol.KDF import HKDF
from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from base64 import b64encode, b64decode

def params():
    p = _sage_const_50043062554237280172405801360375653460619548838234052036762494431728976610313 
    a = _sage_const_43327883319811199442996705732365163443043431995328598938729525921048235234958 
    b = _sage_const_45494814375791703888029144132071347443317277861841182091738819980027414195528 
    gx = _sage_const_34736706601617260336801089627448256371787243214661931571076381713565253696521 
    gy = _sage_const_5887497935320424287803691270199037907654978138532428031269063384390017951571 
    n = _sage_const_2550513000803 
    E = EllipticCurve(GF(p), [a, b])
    G = E(gx, gy)
    return (G, E, n)
    


def keyGen(G, n):
    a = ZZ.random_element(n)
    A = a*G
    return (a, A)
    
def serialize_point_compressed(P):
    #no error in this code
    p = P.curve().base_field().order()
    byte_length = (p.nbits() + _sage_const_7 ) // _sage_const_8 
    x_bytes = int(P[_sage_const_0 ]).to_bytes(byte_length, 'big')
    prefix = b'\x02' if int(P[_sage_const_1 ]) % _sage_const_2  == _sage_const_0  else b'\x03'
    return prefix + x_bytes

def deserialize_point_compressed(data, E):
    #no error in this code
    prefix = data[_sage_const_0 ]
    if prefix not in (_sage_const_2 , _sage_const_3 ):
        raise ValueError("Invalid compression prefix")

    x_bytes = data[_sage_const_1 :]
    x = int.from_bytes(x_bytes, 'big')
    xF = E.base_field()(x)

    # lift_x returns a point with given x and the correct y parity
    try:
        P = E.lift_x(xF, all=False)
    except ValueError:
        raise ValueError("Invalid x: no point found on the curve")

    # Check parity
    if (int(P[_sage_const_1 ]) % _sage_const_2  == _sage_const_0  and prefix == _sage_const_2 ) or (int(P[_sage_const_1 ]) % _sage_const_2  == _sage_const_1  and prefix == _sage_const_3 ):
        return P
    else:
        # Flip to the other y if parity doesn't match
        return -P

def encrypt(A, M, G, n):
    r = ZZ.random_element(n)
    rA = r*A
    k = HKDF(serialize_point_compressed(rA), _sage_const_32 , b"", SHA256, num_keys=_sage_const_1 )
    cipher = AES.new(k, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(M)
    return (serialize_point_compressed(r*G), (cipher.nonce, ciphertext, tag))

def decrypt(a, C, E):
    R = C[_sage_const_0 ]
    S = a * deserialize_point_compressed(R, E)
    k = HKDF(serialize_point_compressed(S), _sage_const_32 , b"", SHA256, num_keys=_sage_const_1 )
    nonce, ciphertext, tag = C[_sage_const_1 ]
    cipher = AES.new(k, AES.MODE_GCM, nonce=nonce)
    message = cipher.decrypt_and_verify(ciphertext, tag)

    return message


def test():
    message = b"Hello mister Duc"
    G, E, n = params()
    a, A = keyGen(G, n)
    print("Message original: ", message)
    #chiffrer
    ciphertext = encrypt(A, message, G, n)
    print("Message chiffré: ", ciphertext)

    #déchiffrer
    plain_text = decrypt(a, ciphertext, E)
    print("Message déchiffré: ", plain_text)

def break_elliptic():
    serialized_public_key_compressed = b'Ay/khAnAnCDHyXhUunDm0088wZ53XFfmX7BSjYuKqp6B'
    c_0_compressed = b'AhECX0JMpcoa5305iHi9JASyB96BTWMOON/u9Va9kcVb' #part rG of the ciphertext
    nonce_compressed = b'KTdd+Y9SanfokDCqypSqBw=='
    ciphertext_compressed = b'qyn5SS4KISE1jfhNOZip/JvDbgsBfmuuE5gRleRu4qGfRCPzWFQAIPPZEVTHQxg6Jha5ulilxEqNmS6aT5GYtbrmMRV2'
    tag_compressed = b'i1QccAPz3D0lJojuU4D9/g=='

    serialized_public_key = b64decode(serialized_public_key_compressed)
    c_0 = b64decode(c_0_compressed)
    nonce = b64decode(nonce_compressed)
    ciphertext = b64decode(ciphertext_compressed)
    tag = b64decode(tag_compressed)

    packet_cipher = (c_0, (nonce, ciphertext, tag))
    G, E, n = params()

    rG = deserialize_point_compressed(serialized_public_key, E)
    print("coucou")
    a = G.discrete_log(rG)
    print("la clé privée est: ", a)

    plain_text = decrypt(a, packet_cipher, E)
    print("Message déchiffré: ", plain_text)


def main():
    #test()
    break_elliptic()

main()

